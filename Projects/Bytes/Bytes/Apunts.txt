														 
														 //TEMA 1: THEORY OF C\\
                                                             
															 //VARIABLES\\

char-> 1 byte que son 8 bits

Short-> 2 bytes que son 16 bits

int-> 4 bytes que son 32 bits

float-> 4 bytes	que son 32 bits 

long-> Segun Ric es una aberracion de la historia es lo mismo que un int

unsigned algo-> es siempre lo mismo que lo que sea pero la diferencia es que el primer hueco esta reservado para quitar el symbol

double-> 8 bytes que son 64 bits 

bool-> es una variable de c++ pero ocupa 1 byte y solo retorna o un 0 o un 1 lo que equivale a un true o false

flag-> es un movimiento de bits
-------------------------------------------------------------------------------------------------------------------------------------
struct texture*           

void*

char*

long*

double*

 - ocupan lo mismo en la memoria
 - tienen el tamaño de todas las variables y su posicion en la memoria                     
 - todo el dato esta almacenado a partir de una direccion de memoria

 void->no retorna nada

 enum-> hace las cosas mas faciles de leer

 EJEMPLO:
       
	   enum positions         
	   {
	     kitchen;            -> 4 ->podemos usar int,float,char....
		 living room;
		 .
		 .
		 .

	   }

-los valores comienzan en "0" porque es mas optimo y a si podriamos usar un char.

typedef->permite tener un "alias" para tipos de datos.

                                                          //OPERADORES\\

operadores aritmeticos:
+ ->suma                        * ->multiplicacion                       % ->modulo,coge el resto de la divison

- ->resta                       / ->division

operador logico:
== ->comparacion					< ->operador menor que               <= ->menor o igual          != ->diferente de            || ->operador or   

= ->asignacion                      > ->operador mayor que               >= ->mayor o igual          && -> operador and

nota: siempre usar parentesis
nota2: siempre van los operadores aritmeticos primero

BOOLE

  AND                 OR
1 && 1 = 1          1 || 1 = 1
1 && 0 = 0          1 || 0 = 1
0 && 1 = 0          0 || 0 = 0
0 && 0 = 0          0 || 1 = 1

operadores chungos:
=   -=  /=
+=  *=  %=

nota3: estos citados anteriormente retornan el valor anterior

operadores de icremento y decremento
a++ ->incrementa uno a a-- -> decrementa uno a a
++a ->                 --a ->
 
													         //FLOW CONTROL\\

if .... .... else if ->para plantear condiciones

while->bucle

for -> otra forma de bucle 

switch -> con el puedes agrupar casos posibles que puedes hacer 

do while -> otra forma de bucle

else -> cuando has planteado una condicion con este le puedes decir cuando no cumpla esa condicion

return -> retorna una variable dando igual el tipo que sea

continue -> 

goto ->

nota4:ya no se suelen usar los dos ultimos


                                                                //PUNTERS\\

nota5: los punteros restan o suman dependiendo del tamaño de la variable que sigue, si es un char iran de 1 en 1 y si es un int iran de 4 en 4

ejemplo:

int a = 3;

int* p1 = &a; 
                  -> le asignamos la direccion de memoria de p1 a p2
int* p2 = p1; 
                                                         
*p2 = 5;          -> con esto el ponemos un 5 en la direccion de memoria recivida
														
nota6: 2 punteros pueden intercambiar sus valores

                                                                 //ARRAYS\\										 

nota7: van siempre consecutivos en la memoria (ej: int a[35])														 
														 
-Heap -> el resto de la memoria que no esta asignada a nosotros con un new estas usando ya la memoria del heap, que siempre es mas que la del stack

-Stack -> En el stack la memoria es siempre limitada														 
														 
int a[15]; -> Este es en el stack														 

int* a = new int[15]; -> Este es para el Heap														 

nota8: recuerda que puedes definir cosas con los define para usarlos siempre tines que: #define  tamany 15

ejemplo de uso de memoria:

int a[15] = 100;
                     => esto es siempre lo mismo, que lo que hace es dar 15 pasos y escribe el 100
int a[tamany] = 100														 
														 
delete []p; -> sirve para borrar un new, ya que siempre que creemos uno hay que hacer un delete, RECUERDA si lleva el new corchetes el delte tambien los llevara.

en los arrays podemos encontra los:                           
  
                                                             //ARRAYS 2D\\														 

nota9: una breve descripcion de estos arrays es que es un array de array 

ejemplo:

int timmy[5][5]

imaginatelo que es como una matriz de 5*5 

si tule dices timmy[1][3]; estaras en la posicion 1*3 y si le dices que es igual a un valor pondra ese valor en esa direccion

                                                                //STRUCT\\

nota10: Un struct es un paquete de variables en las que todo es publico hasta que tu lo declares de otra manera

ejemplo: 

struct Point
{
int x;
int y;
}

Point* a -> es para sacar memoria de la stack

Point* a = new point -> es para cogerlo desde el Heap

como hacer el call para un struct

a[2].y; -> sirve para llamar  a una variable de un struct

a[2]->y; -> para el Heap

. -> variable para el stack

-> ->variable para el heap

//COSAS PARA INVESTIGAR\\

union -> Las union son un tipo especial de struct que permiten almacenar elementos diferentes tipos en las mismas posiciones de memoria, pero no simultaneamente a diferencia de los struct.

memset -> Establece los primeros bytes num del bloque de memoria apuntado por ptr al valor especificado (interpretado como un unsigned char ) 

memcpy -> Copia los valores de bytes num de la ubicación apuntada por fuente directamente al bloque de memoria apuntado por destino.
          El tipo de subyacente de los objetos a la que apunta tanto a los punteros de origen y destino son irrelevantes para esta función ; El resultado es una copia binaria de los datos.
          La función no comprueba para cualquier carácter nulo que termina en fuente - siempre copias exactamente num bytes .
          Para evitar desbordamientos , el tamaño de las matrices apuntado por parámetros tanto del destino y de origen , deberá ser al menos num bytes , y no debe solaparse (por bloques de memoria superpuestas , memmove es un enfoque más seguro ) .

memcmp -> Compara los primeros bytes num del bloque de memoria apuntado por ptr1 a los primeros bytes num apuntadas por ptr2 , devolviendo cero si todo el partido o un valor diferente de cero que representa que es mayor si no lo hacen .
          Observe que , a diferencia de strcmp , la función no se detiene la comparación después de encontrar un carácter nulo

														 //TEMA 2: THEORY OF C++\\

                                                              //INTRO A C++\\
Los cuatro fundamentos de C++ que expanderemos mas adelante son Encapsulacion, Herencia, Polimorfismo, Overload

                                                              //REFERENCIAS\\

nota1: siempre que pases un argumento, lo copia en el stack 

ejemplo:
     
	 struct lista                                                                 
	 {
	   char[100];
	 }
     
	 int sum(lista my_list) -> esto pasa por valor
	 {
	  
	 }

	 double a=5;
	
	 double* b=&a; le pasamos la direccion de memoria
	
	 my_func(b);
	 ->b? cuanto valdra
	 
	 void my_func(double* my_double)
	 {
	  my_double = NULL;//no hace nada porque si yo le digo que me devuelva la *b nos devolvera el contenido tiene preferencia del contenido
	  //y si pones\\ *my_double = 10  //te devolvera el 10 
	 }

	 cuando aparecieron las referencias en c++ 
	 cuando pasamos una referencia simplificamos el lenguaje 
	 
	 2)las referencias no se puede modificar                                          ---->> todo esto no se puede hacer 
	 
	 3)si una vez haz fijado la referencia no se puede alterar

	 4)no pueden ser NULL

	 

	 double a = 5;
	 my_func(a);
	 
	 cuanto vale a???
	 
	 void my_func(double& my_double)
	 {
	 my_double = 10;
	 }
	 



                                                        //Los 4 fundamentos de C++\\
encapsulacion:

son rangos d visivilidad para metodos y atributos.
                  
				  MISMA CLASE                    CLASES DERIVADAS                         OTRAS
-----------------------------------------------------------------------------------------------------
public:            SI                                 SI                                   SI
-----------------------------------------------------------------------------------------------------
protected:         SI                                 SI                                   NO
-----------------------------------------------------------------------------------------------------
private:           SI                                 NO                                   NO
-----------------------------------------------------------------------------------------------------

FRIEND:-> Si tu lo pones en una clase puede acceder a todo lo que sea protected y private en la clase
          en la que esta,

EJEMPLO:
 
 class A
 {
 friend class B;
 };

 la B puede ver todo lo de A, pero la A no puede acceder a todo lo de B
 Todos los datos estan en private hasta que tu indiques lo contratrio

 La diferencia entre struct y class, es que los struct solo almacenan datos, en las clase todo sera privado, pero en el struct todo es publico.
 
--------------------------------------------------------------------------------------------------------------------------------------------------------

HERENCIA:

hacer una especializacion a la clase, hay tres maneras de haces una herencia...


ejemplo: Class A2 : public class A (la clase padre es la A y la hija la A2)
                  : private
				  : protected

si es PUBLIC puedo acceder a los publico que tenga del padre, y lo que sea protected del padre, y al privated nada.

si es PROTECTED  puede covertir las cosas de a publicas es protected, y puede acceder a lo protected, y al privated nada. 

si es PRIVATED hace lo mismo acede a lo publico y en la hija lo vuelve privado, y el protected lo mismo, y lo privated nada.

--------------------------------------------------------------------------------------------------------------------------------------------------------

POLIMORFISMO:

Es un mismo metodo produzca resultados diferentes dependiendo de la especializacion de la clase, la gracia de esto es que no tienes porque conocer 
la especializacion.

---------------------------------------------------------------------------------------------------------------------------------------------------------

 OVERLOADING:

 un ejemplo seria...
 se pueden sobrecargar [] . -> * y un new y delete
 si sobrecargamos el valor asignacion retornara el valor sobrecargado
 return* this; 
 class a
 {
 
 int f(int a); //esto si que es valido
 void (c);

//declaracion de un operador 
 a operador += (const a& p)
 {
 
 }
 
 
 }

 class Point
 {
   int x,y;

   Point operator-(point p)const
   {
   point result;
   result.x = x-p.x;
   result.y = y-p.y;
   return resutl;
   }
 
 
 
 };

 --------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
                                                                        // FRIEND METODES\\
 
-los metodos friend son metodos que se ponen a una clase. Pero no forman parte de la clase, y se tiene que definir en la clase.

-los metodos friend pueden accecder a las variables protected y private.
                                                                     
																		      //CONST\\

-El const adentro no se podra modificar el valor de la referencia

-El const a la izquierda es que el valor que devuelve no se podra modificar 

-El const a la derecha no permite modificar las variables de la clase

const char* const cadena;  cadena++; si que se puede hacer porque no se esta modificando  ahora *cadena = NULL; estaria mal ya que aqui si que lo estas modificando
             Aqui no puedes modificar el valor de la cadena con ese const

                                                                          //Destructores\\

el destructor virtual permite destruir la case hija sin  destruir la clase padre

class Base
{
Base();
~Base();
}

Class Deriv : public Base
{
public:
int* numbers;
                                                                   }------------------>// Y TODO ESTO ES UN MEMORY LICK para evitarlo tendrias que hacer un destructor virtual, llama al destructor y la clase base no se borraria
deriv(){numbers = new int[999];}
~deriv(){delete[] numbers;}
}


mientras tanto en el main:

main()
{
Base* a = new Deriv();
delete a;
}

                                                                            //otro ejemplo:\\

class Base
{
Base(){characters = new char[100];}
~Base(){delete[] characters;}
}

Class Deriv : public Base
{
public:
int* numbers;
                                                                   }------------------>// Y TODO ESTO ES UN MEMORY LICK para evitarlo tendrias que hacer un destructor virtual, llama al destructor y la clase base no se borraria
deriv(){numbers = new int[999];}
~deriv(){delete[] numbers;~Base();}

mientras tanto en el main:

main()
{
Base* a = new Deriv();
delete a;
}

primero llamaria a al de Deriv y luego al de Base

                                                                                                   //CONSTRUCTORES\\
al primero que llamaria seria el de base y luego al de deriv

                                                                                                      //this\\

Base(int x, int y)                    Base(int x, int y):x(x),y(y)
{									  {}
 this->x=x;
 this->y=y;
}
si no pusieramos el this no tendria sentido porque si hay colision
de nombres los argumentos tienen preferencia y estarias igualando una cosa a si misma

                                                                                                 //template meta programing\\

creas codigo que crea codigo (como te comes esto eee porque yo no me lo como)
al hacer un template estas creando codigo, ya que se generan dos archivos, puede ser creeas un int y float por a si decirlo
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                                            //los metodos especiales o automaticos\\
son metodos que hace por defecto en una clase en el c++

class thing
{
public:
thing();->constructor
thing(const thing&)->operador copia solo copia 
~thing();->destructor

thing(thing&&);->operador move solo mueve los datos de uno a otro 
thing operator=(thing&&);->operador asignacion

};

nota1:orden de creacion si todo se cumple

thing(thing&&);
a) 0 constructor de copia 
b) 0 operator = 
c) 0 move
d) 0 detructor 
e) si no esta marcado como a delete 
f)todos los miembros se pueden mover

thing operator=(thing&&);
a)0 copy constructor
b)0 copia de la asignacion
c)0 move constructor
d)0 si no esta mar como delete
e)0 destructor
f)todos los miembros se pueden mover

Ricard 
el te crea un constructor por defecto en caso de que tu no tengas ningun constructor
pero si el detecta que que tienes uno te dira que ya tienes un constructor y te dara error

class A
{
a(int b):num(n);
int num;
}

int main
{
A* pclass = new(a);


}

                                                                          //static\\

igual como la palabra clave const, el modificador static trae confusiones porque se puede utilizar en varios contextos en C y C++. 
Podemos declarar estáticas funciones y métodos. Variables pueden estar estáticas dentro de funciones, métodos, clases y a nivel global, es decir, 
por todas partes.

Variables estáticas locales
----------------------------
Lo más común es declarar una variable local estática:

void mi_funcion_o_metodo(void)
{
    static int var_estatica = 4;
}

El valor de la variable var_estatica no se pierde aunque ya no se encuentre dentro del alcance, es decir, 
cuando el programa haya salido de la función en que la variable fue definida. 
Esto diferencia una variable estática de una variable no estática, cuyo valor se pierde al final de la función.

Debido a esta diferencia, las variables estaticas no se guardan en el stack sino en una memoria especial para variables estáticas.
 Aunque no sean accesibles durante toda la ejecución del programa, las variables estáticas existen durante toda la ejecución del programa.

Igual como en el caso de las variables convencionales, se llama al constructor de las variables estáticas cuando se construyen. 
Esto succede una vez antes de llamar a la función main. Igualmente se llama una vez al destructor después de salir del programa. 
Recuerda que las variables estáticas existen durante toda la ejecución del programa. 
Por eso deben inicalizarse antes de entrar y después de salir de la función principal.

No hay diferencia entre variables estáticas en funciones y métodos de clases. 
De hecho, una variable estática se puede definir dentro de cualquier bloque delimitado por {}.

---------------------------------------------------------------------------------------------------------------------------------------------------

Miembros estáticos de una clase
-------------------------------
Variables miembros de una clase también pueden ser estáticas. 
Una variable estática de una clase es un dato común a todas las instancias de esta clase y accesible en todos los métodos. 
Una variable miembro estática es incluso accesible sin instancia alguna.

En el código siguiente definimos una clase con una variable miembro estática:

class MiClase
{
public:
    static int mi_variable;
};
Esta variable se inicializa así:

int MiClase::mi_variable = 5;
Si la queremos usar sin instancia, entonces usamos el nombre cualificado:

void haz_algo(void)
{
    MiClase::miVariable = 3;
}

Lógicamente, la variable miembro debe ser pública para que la podamos usar fuera de los métodos de la clase. 
(Dentro de los métodos de la clase no hace falta poner el nombre de la clase delante.)

Las variables miembros estáticas existen también durante toda la ejecución del programa. 
Su diferencia con las variables estáticas definidas en una función o método está en su alcance: 
Las variables miembros están al alcance de todos los métodos de una clase y no sólo de uno.

Constantes estáticas
Variables estáticas se pueden declarar también const. Una constante estática es una constante universal del programa, 
pero de alcance limitado. 
Es una buena práctica utilizar constantes estáticas en lugar de macros #define ya que las constantes llevan un tipo: un 5 puede ser un int, 
un char o un float pero un dato

const static int var = 5;
siempre es un int.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Métodos estáticos
-----------------
Métodos de clases también pueden ser estáticas. 
Declarar un método estático es una promesa que este método sólo utiliza miembros estáticos de la clase. 
Este tipo de método no conoce el puntero this, 
por lo cual no se puede hacer directamente referencia a métodos y variables no estátitocs de la clase.

class MiClase
{
public:
    // Una variable estática
    static int una_variable_estatica;
 
    // Una variable no estática
    int una_variable_no_estatica;
 
    // Un método estático
    static void haz_algo(void)
    {
        // Se pueden usar variables estáticas
        una_variable_estatica = 5;
 
        // Error: no se pueden usar variables que
        // requieren un puntero this
        una_variable_no_estatica = 5;  // Error de compilación
    }
 
    // Un método normal (no estático)
    void haz_otra_cosa(void)
    {
        // Se pueden usar variables y métodos estáticos
        // también en métodos no estáticos
        una_variable_estatica = 5;
        haz_algo();
 
        // Una variable de instancia en un método de instancia
        una_variable_no_estatica = 5;  // Correcto
    }
};

Es posible llamar a métodos estáticos de una clase sin tener una instancia de ella utilizando el nombre cualificado.

void una_funcion_cualquiera(void)
{
    // Correcto: Se puede llamar a un método no estático
    // si instancia
    MiClase::haz_algo();
 
    // Sin embargo, también se le puede llamar con instancia
    MiClase mi_instancia;
    mi_instancia.haz_algo();
 
    // No es posible llamar a un método convencional
    // sin instancia
    MiClase::haz_otra_cosa();  // Error de compilación
}

Métodos estáticos son similares a funciones globales. 
Sólo llevan el nombre de la clase como prefijo. 
(Un nombre de espacio no se usa de forma diferente que una clase con todos los miembros públicos y estáticos.)

Métodos estáticos pueden sobrecargar los nombres métodos no estático. 
De hecho es una práctica bastante común  sobre todo para métodos recursivos. 
Como ejemplo podemos considerar una clase String, en que un método convencional afecta a la instancia de una clase, 
mientras el método estático a un parámetro.


class String
{
public:
 
    // Crea una instancia con todas las letras del parámetro 
    // convertidas a minúsculas.
    static String a_minusculas(const String& instancia_de_string);
 
    // Convierte todas las letras de ESTA instancia a minúsculas
    void a_minusculas(void)
    {
        *this = a_minusculas(*this);
    }
}













































































